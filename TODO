Ajouter une LICENCE, README et INSTALLATION
Finir les tests unitaires de l'auditeur
Move to English (messages, names...)
Tester la couverture de code
Passer sur SQLITE
Mettre les dictionnaires en fichiers .ini ou en bases SQLite (ou autres)
Comment inclure les applications de références? (TAR)
Pouvoir utiliser un autre php que le PHP système

Pouvoir relire les objets depuis MySQL
Faire une interface fluide pour construire les requêtes SQL
Avoir des rapports intermédiaires rapides (nouveaux tags?)
Passer la liste chaînée en SPL
Avancer les tests unitaires pour l'auditeur

Accumuler les résultats 
Avoir une vue pour l'auditeur (export HTML, PDF, ODT)
Pouvoir paraleliser les analyses de code (gearman? une liste de fichier en base? Faire les fichiers récents ou qui n'ont pas été finis.. )

Noter le délimiteur des litéraux et le retirer de la valeur
Mettre toutes les méthodes en anglais
Ajouter une licence dans tous les fichiers


Mettre un verificateur automatique de hasPrev et hasNext dans analyseur
Faire un log d'utilité des tests

retirer l'utilisation des getNext() dans les regex
Utiliser un getNext() avec cache dans applyRegex
Compter les GetNext et getPrev dans les stats

appliquer immédiatement les litéraux pour ne pas faire un double passage

mettre les code comme les tokens pour moreceler encore plus les recherches

avoir une fonction qui 'prèfere' certain token, une fois qu'une classe a été ouverte

prévoir un système pour modifier les conditions automatiquement, et voir si on peut en retirer / ajouter sans que cela pertrube les tests.

Convertir les constructeurs à $entree, et vérifier leur nombre à chaque fois. 
Ajouter des messages d'erreurs significatifs (actuellement, des DIE avec message en dure)

Migrer la liste chaînée vers la SPL 

Ajouter mon propre code dans reference.sh
Ajouter elgg et OBM

Pouvoir désactiver un token (suppréssion par défaut, si pas compris? )



autres idées : 
SImplifier le code, pour l'exprimer sous la forme de liens : entrant, combiné, sortant
définition des fonctions/classes
utilisation des fonctions et classes
utilisations des globales
query, protection, 

Faire des statistiques globales sur toute l'application

Faire des stats inversées (variables par fichiers, et fichiers par variables)

Extraire le core d'un script (sans les définition, classes et fonctions)
Extraire les affectations de variables (une a l'autre)
Extraire les variables d'entrée et celles de sorties.
utilisation des super globales (affectations, passages en paramètre, etc).
identifications des variables de register globale
Repérer le code PHP adns les commentaires
Repérer le code SQL ou HTML dans les chaînes
Extraire les interferances entre les noms (variables, constantes, fonctions, classes, HTML, SQL).
Extraire les foreach simples (un ou deux lignes) : c'est souvent des opérations élémentaires de rattrappage d'une situation.

Tokens : trouver le début de l'instruction.

Repérer les regex utilisées

Faire des tests unitaires sur les fonctions de soutien token_*
Calculer le contexte courant (nom de la classe, fonction ou global)
Calculer le numéro d'instruction (sortir un arbre d'exécution?)

Faire un affichage par cle et par valeur de chaque tableau (cle => valeur). 

produire un arbre d'appel des fonctions (quelle fonction appelle quelle autre), et passer le tout à graphviz

Recherche d'une chaîne spéciale, indépendemment des tokens
    Capitalisation des valeurs trouvées (via une base? ) 
    Sélection de différents types de token trouvés



+ (XT)ML protection function usage
+ (XT)ML unprotection function usage
[+] @ operator usage
+ Comments usage
[+] Constante usage
[+] Constants defintions (define(X, 2);)
[+] Debugging functions usage
[+] echo and print usage
[+] eval() usage
[+] File inclusions
[+] Global variable usage
[+] header() usage
+ Liste of classes definition
[+] Liste of empty function definition
[+] Liste of function definition
+ Massive variable creation
[+] native function for dir manipulation
[+] native function for file manipulation
+ Nested loops
+ PHP configuration function usage
[+] PHP native function usage
+ Regex usage (pcre, ereg)
+ Script interruption with (die, exit)
+ Script mail usage
+ SQL queries lists
+ SQL queries protections
[+] Superglobal variables usage
+ System function usage (exec, shell_exec, system)
+ Upper case variables
+ URL manipulations
+ User functions usage
[+] Utilisation des fonctions de gestion de fichiers
[+] Variable affectations (type : $x = 2;)
[+] variable variables usage
+ Variables being used


Stats (juste les nombres d'occurrences par elements)
stats par fichier (nombre d'elements par fichier)
par element, fichiers impliqués
par fichier, elements présents

Faire la fiche d'une fonction :
entrée (global, statiques, membres)
sortie (return)
local (variables)



Pouvoir cocher les elements qui ont été validés manuellement (ajouter une colonne, et un tick dans l'interface, MAJ des informations)
Faire une répartition par fichier (actuel), par classe, par scope. 
avoir une option -log pour exporter dans un fichier de log

Faire la liste des dépendences entre les rapports (certains ont besoin des autres)
faire la liste des classes et des méthodes (inventaire)
Faire la liste des méthodes/fonctions, constantes/constantes de classes, variable/propriétés
Faire une option de nettoyage des bases (par défaut, c'est remis fichier par fichier)


methodes appelées
exceptions lancées
fonctions/méthodes lanceuses d'exception

méthodes pas appelées
propriétés pas appelées

Extraire les abstracts des arguments inutilisés

Manage manual feedback (from where? Web? )
Add levels of nesting : class, function, method, if/switch/loop/block 
Identifier les types de données quand c'est possible (intval, new, etc...)

Automatically note configuration in .INI from tokenizeur/auditeur if .ini doen't exist (easy creation)
merge all .ini in one
make the web publication a simple include
find a nice display for auditeur export in HTML/Web version
See how cache template must be used with mysql/sqlite

Merge todos from auditeur and tokenizeur in one. 

Make the comment analyzer, to gather suggestion from code (@todo, @question, @.? )
Add an option for the tokenizeur to clean the tables before working (default : append new files). 
Stop script when option is unrecognized (all of them);
Display dots when parsing the file (tokenizer)
Display dots when processing analyzers (auditeur)

Detect multiple definitions of functions/classes (things that should be there only once : how can we process that then?)
Detect missing elements in classes (like methods, properties, etc)

Add INI in the PHPFilter class of the tokenizer.
List open-ended inclusions (including files that we don't know about)

GLobals : distinguish statics and globals, and also implicit or explicit one.s